# Structural Frameworks and Optimization Techniques in Rendering Engines

## Summary
In this article, we’ll look at the structure behind a rendering engine following the SOLID principles, aiming to create a simplified rendering engine with a modular and easily expendable codebase. To get a good understanding of the content of the article, a good understanding of the basics of rendering is advised. We’ll look at multiple problems and their solutions while discussing alternate approaches and improvements. We’ll look at creating an external library and entry point to make the codebase easily reusable, ways to integrate the rendering API effectively, and design patterns used to support multiple external libraries at once. We also discuss approaches for creating an asset manager that is adjusted to the article’s scope and alternative improved and optimized ways to create one. In the final part of the article, we’ll discuss some essential aspects of the rendering pipeline and how to take these aspects into account when creating a rendering pipeline. We aim to create a simple scene with basic lighting, asset importing, and a skybox.

## Introduction
Since the dawn of computers, video games have taken the entertainment market by storm. From the bare beginnings with arguably one of the most well-known games, Pong, to the most visually stunning games released today, it’s fair to say video games have come quite far. Video games have also become increasingly complex, which can be great for users but creates a big challenge for developers. More complex games mean bigger codebases; Bigger codebases mean well-considered structures and thoughtful decisions; And well-considered structures and thoughtful decisions mean knowledge of bigger codebases, design patterns, and software structures.

From the cooperation of multiple modules while following the SOLID principles to the easy-to-use interface while still maintaining acceptable performance, it’s fair to say that creating a big, well-structured codebase is nothing short of a challenge. A lack of in-depth documentation and tutorials on bigger codebases also doesn’t help solve this problem. Even though the ability to write bigger codebases comes with the experience of writing smaller codebases and iteratively increasing the size of these projects, recognizing patterns and ways to increase code quality can increase the speed of improvement significantly.

This article aims to help developers improve their software design, specifically rendering engines, by creating a rendering engine from scratch, motivating design choices, and discussing alternative strategies for solving a certain problem. Because visualization is challenging while talking about structure and code design, there will be heavy use of UML diagrams and code snippets where applicable.

## Implementation
Project type
Ideally, an engine has a reusable codebase that applies to various projects, be it a rendering, game, or audio engine. Software should be able to utilize this engine without being amalgamated into the codebase. Instead, it should be an external library linked to the software, accessed through an engine-specific interface. This encapsulates all the functionality-specific logic, allowing users to focus on content creation without thinking about actual implementation. Our rendering engine should thus contain both a rendering implementation and an interface to communicate.

External libraries come in two types: static and dynamic libraries. Although this doesn’t significantly affect the rendering engine’s overall codebase, it’s good to consider your engine’s possibilities and limitations. Considering a project type early can save time and allow us to consider possible structural changes in the design phase.

A static library (LIB) is a static codebase that gets compiled into our project when compiled. This allows us to access the codebase and utilize its functionality easily. Since we’re directly fusing the library into our project, the compiler will copy and paste code from the library into our project where necessary, which can lead to duplicate code. The dynamic library (DLL) is primarily focused on dynamic codebases and tries to solve the code duplication drawback. The premise of the DLL is that, instead of compiling the library directly into our project, it can be run by mapping it into our program as it is loaded into memory. This makes sure we only use a single copy of the library at any point, saving memory. Additionally, it allows us only to load specific libraries, saving additional memory. One downside of a DLL is that we have to make sure a copy of the dynamic library is installed on every machine your program runs, which creates its own set of problems. (DLL And LIB Files – What and Why?, n.d.)

Since our engine will be a static codebase, all functionality will be used, and the duplication of code won’t have a significant impact, it is not surprising that we opted for a static library engine.

## Entry point
While maintaining the separation between the two codebases, we still need a way to communicate. A conventional approach is to treat the library as precisely that—a library. Accessing the library involves calling a function that executes the requested action. This way, our project retains control over its lifespan while the library follows its commands.